#include <iostream>
#include <ctime>
using namespace std;

/*
 * Η συνάρτηση Xor() δέχεται τέσσερα ορίσματα την συμβολοσειρά newm που είναι ο διαιρεταίος, την συμβολοσειρά P που είναι ο
 * διαιρέτης, την ακέραια μεταβλητή n που είναι το άθροισμα του k που δίνεται από τον χρήστη με το μέγεθος του μεγέθους
 * της συμβολοσειράς P που επίσης δίνεται από τον χρήστη μειωμένο κατά ένα, και την ακέραια μεταβλητή k που το δίνει ο
 * χρήστης. Αρχικά αποθηκεύονται στην συμβολοσειρά D τα πρώτα n-k+1 (μέγεθος του P) στοιχεία του newm. Εάν ο πρώτος
 * χαρακτήρας της D είναι 0 τότε αντιγράφουμε στην συμβολοσειρά fcs την D εκτός του πρώτου χαρακτήρα. Εάν δεν είναι 0
 * για κάθε χαρακτήρα της συμβολοσειράς D ελέγχεται εάν ισούται με αυτόν στην αντίστοιχη θέση της D και αν ισούνται
 * προσθέτουμε 0 στο τέλος της fcs αλλιώς 1 στην συνέχεια προσθίθεται το επόμενο στοιχείο της newm και η διαδικασία
 * επαναλαμβάνεται k-1 φορές. Με αυτόν τον τρόπο υπολογίζεται το υπόλοιπο της newm με το P και επιστρέφεται.
 */
string Xor(string newm, string P, int n, int k){
    string fcs;
    int pos = 0;
    string D = newm.substr(0, n-k+1);
    while (pos < k-1) {
        if (D[0] == '1') {
            for (int i = 1; i < n - k + 1; ++i) {
                if (D[i] == P[i]) {
                    fcs += '0';
                } else {
                    fcs += '1';
                }
            }
        } else {
            fcs = D.substr(1, D.length());
        }
        fcs += newm[n - k + 1 + pos];
        D = fcs;
        fcs = "";
        pos++;
    }
    return D.substr(1, D.length());
}

/*
 * Η συνάρτηση noisyChannel() δέχεται δύο ορίσματα την συμβολοσειρά M που είναι το μύνημα και την ακέραιο μεταβλητή BER
 * και υλοποιεί το ενθώρυβο κανάλι. Αρχικά αποθηκεύει στην πραγματική μεταβλητή k έναν τυχαίο αριθμό μεταξύ του 0 και
 * του 1. Εάν ο k είναι μικρότερος από το BER τότε αντισρέφει το χαρακτήρα της συμβολοσειράς (από 0 σε 1 και από 1 σε 0).
 * Η διαδικασία αυτή γίνεται για όλους τους χαρακτήρες της συμβολοσειράς M και στο τέλος επιστρέφεται.
 */
string noisyChannel(string M, double BER){
    double k;
    for (int i = 0; i < M.length(); ++i) {
        k = ((double)rand()/(double)(RAND_MAX));
        if (k < BER){
            if (M[i] == '0'){
                M[i] = '1';
            } else {
                M[i] = '0';
            }
        }
    }
    return M;
}

/*
 * Στην συνάρτηση main ζητείται από τον χρήστη η εισαγωγή της ακέραιας μεταβλήτής k που είναι το μέγεθος της προς μετάδοσης
 * ακολουθίας, της πραγαμτικής μεταβλητής BER που χρησιμοποιείται στο ενθόρυβο κανάλι και της συμβολοσειράς P η οποία
 * αποτελεί τον διαιρέτη στο CRC. Στην συνέχεια, ορίζεται η τιμή της ακέραιας μεταβλητής n που είναι το μέγεθος της
 * της ακολουθίας που πρόκειται να μεταδοθεί, σύμφωνα με τα δεδομένα που έχει εισάγει ο χρήστης. Έπειτα ακολουθεί ένας
 * βρόγχος 1000000 επαναλήψεων μέσα στον οποίο σε κάθε επανάληψη δημιουργείται μια ακολουθία των k bits που ξεκιναει με
 * 1 και για τα υπόλοιπα ψηφία το 0 και το 1 έχουν ίση πιθανότητα εμφάνισης, η οποία αποθηκεύεται στην συμβολοσειρά D.
 * Στην μεταβλητή newD αποθηκεύεται αρχικά η D και στην συνέχεια πολλαπλασιάζεται με 2^(n-k) δηλαδή προστίθενται n-k
 * μηδενικά στο τέλος. Καλείται η συνάρτηση Xor() με ορίσματα τα newD, P, n και k η οποία υπολογίζει το υπόλοιπο της
 * διαίρεσης του newd με το P και το επιστρέφει αποθηκεύοντάς το στην συμβολοσειρά R. Στην συνέχεια στην συμβολοσειρά Τ
 * αποθηκεύεται η συνένωση των ακολουθιών 2^(n-k)*D και R. Καλείται η συνάρτηση noisyChannel με ορίσματα την T και τον BER
 * η οποία αλλάζει κάθε ψηφίο της T αλλάζει με πιθανότητα BER και το αποτέλεσμα αποθηκεύεται στην newD. Αν το newD είναι
 * διάφορο του T τότε σημαίνει ότι το μύνημα μεταδόθηκε με λάθος και αυξάνεται ο μετρητής counter1. Καλείται Καλείται η
 * συνάρτηση Xor() με ορίσματα τα newD, P, n και k ώστε να ελεγχθεί αν ανιχνεύθηκε με σφάλμα. Το υπόλοιπο αποθηκεύεται
 * στη R αν είναι 0 τότε το CRC δεν ανίχνευσε σφάλμα ενώ αν είναι διάφορο αυξάνεται ο μετρητής counter. Τέλος εμφανίζονται
 * τα ποσοστά των μυνημάτων που μεταδόθηκαν με σφάλμα, των μυνημάτων που μεταδόθηκαν με σφάλμα και εντοπίστηκαν από το
 * CRC αλλά και αυτών που δεν εντοπίστηκαν.
 */
int main() {
    srand((int) time(0));

    int k;
    double BER;
    string P;
    cout << "Give k:";
    cin >> k;
    cout << "Give BER:";
    cin >> BER;
    cout << "Give P:";
    cin >> P;
    while (P[0]!='1'){
        cout << "The first digit should not be zero!" << endl << "Give P:";
        cin >> P;
    }

    int counter = 0;
    int counter1 = 0;

    int n = k + P.length() - 1;
    for (int i = 0; i < 1000000; ++i) {
        string D = "1";
        for (int i = 0; i < k-1; ++i) {
            D += to_string(rand()%2);
        }
        string newD = D;
        for (int i = 0; i < n-k; ++i) {
            newD += '0';
        }
        string R = Xor(newD, P, n, k);
        string T = D + R;
        newD = noisyChannel(T, BER);
        if (newD != T){
            counter1++;
        }
        R = Xor(newD, P, n, k);
        for (int j = 0; j < R.length(); ++j) {
            if (R[j] != '0'){
                counter++;
                break;
            }
        }
    }
    cout << (double)counter1/10000 << "% (" << counter1 << ") of the transmitted messages had error." << endl;
    cout << (double)counter/10000 << "% (" << counter << ") of the transmitted messages had error and got detected by the CRC." << endl;
    cout << (double)(counter1-counter)/10000 << "% (" << counter1-counter << ") of the transmitted messages had error and didn't get detected by the CRC." << endl;

}